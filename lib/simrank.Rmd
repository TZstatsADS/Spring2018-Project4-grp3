---
title: "simrank"
author: "Wenshan Wang"
date: "4/10/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# compute pairwise user sim
```{r}
compute_user_cum_movie_sum = function(m1,m2,
                                      Movie_Matrix_ = Movie_Matrix) {
  
  return(Movie_Matrix_[m1,m2])
}

compute_user_sim = function(j, k, iter = i,
                            train_adj_ = train_adj,
                            Movie_Matrix_ = Movie_Matrix,
                            Users_ = Users,
                            Movies_ = Movies) {
  
  if (j == k) {
    return(1)
  } else {
    moviesj = train_adj_$Movie[which(train_adj_$User == Users_[j])]
    moviesk = train_adj_$Movie[which(train_adj_$User == Users_[k])]
    
    # moviesj = c(2,3)
    # moviesk = c(3,4,5)
    # Movies_ = c(1:6)
    
    
    # Pruning
    # simrank is 0 if number of intersection of movies <= 0.25*user j's number of movie
    if (length(moviesj) + length(moviesk) - 
        length(unique(c(moviesj,moviesk))) <= 0.25 * length(moviesj)) {
      return(0)
    }
    
    # First Iter
    if (iter == 1) {
      return((length(moviesj) + length(moviesk) - 
               length(unique(c(moviesj,moviesk)))) * 0.8 / length(moviesk) / length(moviesj))
    }
    
    # find the index of moviesj (each length moviesk) in Movies_
    m1s = match(sort(rep(moviesj,length(moviesk))),Movies_)
    m2s = match(rep(moviesk,length(moviesj)),Movies_)
    
    mins = (m1s+m2s - sqrt((m1s-m2s)^2) )/2
    maxs = (m1s+m2s + sqrt((m1s-m2s)^2) )/2
    
    cum_sum = sum(mapply(compute_user_cum_movie_sum,
                         m1 = maxs, 
                         m2 = mins), na.rm=T)
    
    cum_sum = cum_sum * 0.8 / length(mins)
    return(cum_sum)
  }
}
```

# compute pairwise movie sim
```{r}
compute_movie_cum_user_sum = function(m1,m2,
                                      User_Matrix_ = User_Matrix) {
  
  return(User_Matrix_[m1,m2])
}

compute_movie_sim = function(j, k, 
                            train_adj_ = train_adj,
                            User_Matrix_ = User_Matrix,
                            Users_ = Users,
                            Movies_ = Movies) {
  
  if (j == k) {
    return(1)
  } else {
    usersj = train_adj_$User[which(train_adj_$Movie == Movies_[j])]
    usersk = train_adj_$User[which(train_adj_$Movie == Movies_[k])]
    
    if (length(usersj) + length(usersk) - 
        length(unique(c(usersj,usersk))) <= 0.25 * length(usersj)) {
      return(0)
    }
    
    m1s = match(sort(rep(usersj,length(usersk))),Users_)
    m2s = match(rep(usersk,length(usersj)),Users_)
    
    mins = (m1s+m2s - sqrt((m1s-m2s)^2) )/2
    maxs = (m1s+m2s + sqrt((m1s-m2s)^2) )/2
    
    cum_sum = sum(mapply(compute_movie_cum_user_sum,
                         m1 = maxs, 
                         m2 = mins),na.rm=T)
    
    cum_sum = cum_sum * 0.8 / length(mins)
    return(cum_sum)
  }
}

```



# genrerate simrank data
```{r}
train <- read.csv("../data/data_sample/eachmovie_sample/data_train.csv")
test <- read.csv("../data/data_sample/eachmovie_sample/data_test.csv")

# recalcculate the score (if larger than 6 -> 1)
train$rescore <- ifelse(train$Score>=6, 1, 0)
# only keep the rows/observations that rescore == 1
train_adj = train[which(train$rescore ==1),]

# get movie and user id (unique)
Movies = sort(unique(train_adj$Movie))
Users = unique(train_adj$User)

# initiate movie mat and user mat
Movie_Matrix = diag(length(Movies))
User_Matrix = diag(length(Users))

# iterate 5 times, update user matrix and movie matrix each time
for( i in 1:5 ) {
  for (j in 1:length(Users)) {
    # fill in the lower triangular 
    User_Matrix[j,1:j] = mapply(compute_user_sim,j=j,k=1:j)
  }
  for (j in 1:length(Movies)) {
    Movie_Matrix[j,1:j] = mapply(compute_movie_sim,j=j,k=1:j)
  }
}

# let the upper trangular part of the matrix equal to the lower trangular part of the matrix
User_Matrix[upper.tri(User_Matrix)] <- t(User_Matrix)[upper.tri(User_Matrix)]

## then the user_matrix is done

```

